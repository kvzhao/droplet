# shell-script
1 0 GfsSimulation GfsBox GfsGEdge {} {
Time { end = 20.0 }
   Global {
      #define D0           3.3e-3
      #define V0           3.59
      #define RHO_L        1178.
      #define RHO_G        1.2
      #define MU_L         18.8e-3
      #define MU_G         1.7e-5
      #define SIGMA_L      71.22e-3
      #define g            9.81
      #define Re RHO_L*V0*D0/MU_L 
      #define We RHO_L*V0*V0*D0/SIGMA_L
      #define Fr V0*V0/g/D0 
      #define H 14*D0
      #define radius  D0/2
      #define pool_depth 7.2*D0
      #define epsilon 1e-5
      #define var(T,min,max) (CLAMP(T,0,1)*(max-min)+min)
      #define rho(T) var(T,RHO_G/RHO_L,1.)
      #define mu(T)  var(T,MU_G/MU_L,1.)
      #define level 9
}

# Solver parameters
Refine level
ProjectionParams { tolerance = 1e-6 }
ApproxProjectionParams { tolerance = 1e-6 }

VariableTracerVOF T
VariableFiltered T1 T 1
VariableCurvature K T Kmax

PhysicalParams {L = H}
InitFraction T ({
   double drop = sphere(-.5 * H, -.5 * H + pool_depth + 0.52 * D0, 0, radius);
   double film = y + (.5 * H - pool_depth);
   return -union(drop, film);
})

Init{} { V = ( y > -0.5 * H ? -T : 0.)}

PhysicalParams{ alpha = 1./rho(T1) }
SourceViscosity (2.*radius*mu(T1))/(Re*rho(T1))
SourceTension T 2.*radius/We K

# we need the gravity
Source V -1./(2.*radius*Fr)

AdaptVorticity {istep = 1 } {cmax=1e-2 maxlevel=level }
AdaptGradient  {istep = 1 } {cmax=1e-3 maxlevel=level } T

OutputScalarSum { istep = 1 } k { v = Velocity2*rho(T1) }
OutputScalarSum { istep = 1 } t { v = T }

OutputSimulation { istep = 20 } res%08ld.gfs
OutputSimulation { istep = 20 } animation%08ld.vtk { format = VTK }
OutputSimulation { istep = 20 } data%08ld.dat { format = text}

OutputTime { istep = 20 } stderr

}
GfsBox {
  top = BoundaryOutflow
  left = Boundary
  right = Boundary
}
